---
title: Как и где использовать итераторы
linktitle: Итерация данных
type: docs
weight: 640
url: /ru/java/how-and-where-to-use-iterators/
---

{{% alert color="primary" %}} 

Объект интерфейса итератора можно использовать для обхода всех элементов коллекции. Итераторы можно использовать для проверки данных в коллекции, но их нельзя использовать для модификации базовой коллекции. В общем, чтобы использовать итератор для перебора содержимого коллекции, нужно выполнить следующие шаги:

1. Получить итератор в начало коллекции, вызвав метод итератора коллекции.
1. Настроить цикл, который делает вызов метода hasNext. Пусть цикл работает до тех пор, пока метод hasNext возвращает true.
1. Внутри цикла получить каждый элемент, вызвав метод next.

API Aspose.Cells предоставляет множество итераторов, однако в этой статье главным образом обсуждаются три типа, перечисленных ниже.

1. Итератор ячеек
1. Итератор строк
1. Итератор столбцов

{{% /alert %}} 
## **Как использовать итераторы**
### **Итератор ячеек**
Существует несколько способов получения итератора ячеек, и можно использовать любой из этих методов в зависимости от требований приложения. Ниже приведены методы, возвращающие итераторы ячеек.

1. Cells.iterator
1. Row.iterator
1. Range.iterator

Все упомянутые выше методы возвращают итератор, который позволяет обойти коллекцию ячеек, которая была инициализирована.

{{% alert color="primary" %}} 

При обходе ячеек коллекция не должна изменяться (операции, которые приведут к созданию новой ячейки или удалению существующей ячейки). В противном случае итератор может не смочь правильным образом обойти все ячейки (некоторые элементы могут быть обойдены несколько раз или пропущены).

{{% /alert %}} 

Приведенный ниже пример кода демонстрирует реализацию класса Iterator для коллекции ячеек.







{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-CellsIterator-CellsIterator.java" >}}




##### **Итератор строк**
Итератор строк может быть получен при использовании метода RowCollection.iterator. Приведенный ниже пример кода демонстрирует реализацию итератора для класса RowCollection.





{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-RowsIterator-RowsIterator.java" >}}




##### **Итератор столбцов**
Итератор столбцов доступен при использовании метода ColumnCollection.iterator. Приведенный ниже пример кода демонстрирует реализацию итератора для класса ColumnCollection.





{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-ColumnsIterator-ColumnsIterator.java" >}}




#### **Где использовать итераторы**
Чтобы обсудить преимущества использования итераторов, давайте рассмотрим реальный пример.
##### **Сценарий**
Требуется пройти по всем ячейкам в данной таблице, чтобы прочитать их значения. Существует несколько способов реализации этой цели. Некоторые из них показаны ниже.
###### **Использование диапазона отображения**




{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-UsingDisplayRange-UsingDisplayRange.java" >}}




###### **Использование MaxDataRow и MaxDataColumn**




{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-UsingMaxDataRowAndMaxDataColumn-UsingMaxDataRowAndMaxDataColumn.java" >}}





Как можно заметить, что оба вышеупомянутых подхода используют более или менее аналогичную логику, то есть проходят по всем ячейкам в коллекции для чтения значений ячеек. Это может быть проблематичным по ряду причин, как обсуждается далее.

1. API, такие как MaxRow, MaxDataRow, MaxColumn, MaxDataColumn и MaxDisplayRange, требуют дополнительного времени для сбора соответствующей статистики. Если матрица данных (строки x столбцы) большая, использование этих API может повлечь штраф производительности.
1. В большинстве случаев не все ячейки в заданном диапазоне созданы. В таких ситуациях проверка каждой ячейки в матрице не так эффективна, как проверка только инициализированных ячеек.
1. Обращение к ячейке в цикле как Cells.get(rowIndex, columnIndex) приведет к созданию всех объектов ячеек в диапазоне, что в конечном итоге может вызвать ошибку OutOfMemoryError.
##### **Заключение**
На основе вышеприведенных фактов перечислены возможные сценарии, в которых следует использовать итераторы.

1. Требуется только чтение коллекции ячеек, то есть требуется только проверка ячеек.
1. Необходимо пройти большое количество ячеек.
1. Необходимо обойти только инициализированные ячейки/строки/столбцы.
