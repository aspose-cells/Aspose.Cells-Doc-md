---
title: Как и где использовать итераторы
linktitle: Повторить данные
type: docs
weight: 640
url: /ru/java/how-and-where-to-use-iterators/
---
{{% alert color="primary" %}} 

Объект интерфейса итератора можно использовать для обхода всех элементов коллекции. Итераторы можно использовать для проверки данных в коллекции, но их нельзя использовать для изменения базовой коллекции. В общем случае, чтобы использовать итератор для циклического просмотра содержимого коллекции, необходимо выполнить следующие шаги:

1. Получите итератор в начало коллекции, вызвав метод итератора коллекции.
1. Настройте цикл, который вызывает метод hasNext. Цикл повторяется до тех пор, пока метод hasNext возвращает значение true.
1. В цикле получите каждый элемент, вызвав метод next.

Aspose.Cells API предоставляют множество итераторов, однако в этой статье в основном обсуждаются три типа, перечисленные ниже.

1. Cells Итератор
1. Итератор строк
1. Итератор столбцов

{{% /alert %}} 
## **Как использовать итераторы**
### **Cells Итератор**
Существуют различные способы доступа к итератору ячеек, и любой из этих методов можно использовать в зависимости от требований приложения. Вот методы, которые возвращают итератор ячеек.

1. Cells.iterator
1. Строка.итератор
1. Range.iterator

Все вышеупомянутые методы возвращают итератор, который позволяет пройти по коллекции ячеек, которые были инициализированы.

{{% alert color="primary" %}} 

При обходе ячеек коллекция не должна изменяться (операции, которые приведут к созданию нового экземпляра Cell или удалению существующего Cell). В противном случае итератор не сможет правильно пройти все ячейки (некоторые элементы могут быть пройдены повторно или пропущены).

{{% /alert %}} 

В следующем примере кода демонстрируется реализация класса Iterator для коллекции ячеек.







{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-CellsIterator-CellsIterator.java" >}}




##### **Итератор строк**
Доступ к итератору строк можно получить при использовании метода RowCollection.iterator. В следующем примере кода демонстрируется реализация класса Iterator для RowCollection.





{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-RowsIterator-RowsIterator.java" >}}




##### **Итератор столбцов**
Доступ к итератору столбцов можно получить при использовании метода ColumnCollection.iterator. В следующем примере кода демонстрируется реализация класса Iterator для ColumnCollection.





{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-ColumnsIterator-ColumnsIterator.java" >}}




#### **Где использовать итераторы**
Чтобы обсудить преимущества использования итераторов, давайте рассмотрим пример в реальном времени.
##### **Сценарий**
Требование к приложению состоит в том, чтобы пройти по всем ячейкам данного рабочего листа, чтобы прочитать их значения. Способов реализации этой цели может быть несколько. Некоторые из них показаны ниже.
###### **Использование диапазона отображения**




{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-UsingDisplayRange-UsingDisplayRange.java" >}}




###### **Использование MaxDataRow и MaxDataColumn**




{{< gist "aspose-cells-gists" "5876dc77e47649b66bdb5deefb4b5639" "Examples-src-main-java-com-aspose-cells-examples-articles-UsingMaxDataRowAndMaxDataColumn-UsingMaxDataRowAndMaxDataColumn.java" >}}





Как вы можете заметить, оба вышеупомянутых подхода используют более или менее схожую логику, то есть; цикл по всем ячейкам в коллекции, чтобы прочитать значения ячеек. Это может быть проблематично по ряду причин, как описано ниже.

1. Такие API, как MaxRow, MaxDataRow, MaxColumn, MaxDataColumn и MaxDisplayRange, требуют дополнительного времени для сбора соответствующей статистики. Если матрица данных (строки x столбцы) велика, использование этих API может привести к снижению производительности.
1. В большинстве случаев создаются не все ячейки в заданном диапазоне. В таких ситуациях проверять каждую ячейку матрицы не так эффективно, как проверять только инициализированные ячейки.
1. Доступ к ячейке в цикле как Cells.get(rowIndex, columnIndex) приведет к созданию экземпляров всех объектов ячеек в диапазоне, что в конечном итоге может вызвать OutOfMemoryError.
##### **Заключение**
Основываясь на вышеупомянутых фактах, ниже приведены возможные сценарии использования итераторов.

1. Требуется доступ только для чтения к коллекции ячеек, т.е. Требование состоит в том, чтобы осматривать только ячейки.
1. Необходимо пройти большое количество клеток.
1. Только инициализированные ячейки/строки/столбцы должны быть пройдены.
